<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PAMI.frequentPattern.maximal.MaxFPGrowth &mdash; PAMI 2024.04.23 documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../../_static/documentation_options.js?v=391540b0"></script>
        <script src="../../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            PAMI
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../modules.html">PAMI</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">PAMI</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">PAMI.frequentPattern.maximal.MaxFPGrowth</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for PAMI.frequentPattern.maximal.MaxFPGrowth</h1><div class="highlight"><pre>
<span></span><span class="c1"># MaxFP-Growth is one of the fundamental algorithm to discover maximal frequent patterns in a transactional database.</span>
<span class="c1">#</span>
<span class="c1"># **Importing this algorithm into a python program**</span>
<span class="c1"># ---------------------------------------------------------</span>
<span class="c1">#</span>
<span class="c1">#             from PAMI.frequentPattern.maximal import MaxFPGrowth as alg</span>
<span class="c1">#</span>
<span class="c1">#             obj = alg.MaxFPGrowth(&quot;../basic/sampleTDB.txt&quot;, &quot;2&quot;)</span>
<span class="c1">#</span>
<span class="c1">#             obj.mine()</span>
<span class="c1">#</span>
<span class="c1">#             frequentPatterns = obj.getPatterns()</span>
<span class="c1">#</span>
<span class="c1">#             print(&quot;Total number of Frequent Patterns:&quot;, len(frequentPatterns))</span>
<span class="c1">#</span>
<span class="c1">#             obj.save(&quot;patterns&quot;)</span>
<span class="c1">#</span>
<span class="c1">#             Df = obj.getPatternsAsDataFrame()</span>
<span class="c1">#</span>
<span class="c1">#             memUSS = obj.getMemoryUSS()</span>
<span class="c1">#</span>
<span class="c1">#             print(&quot;Total Memory in USS:&quot;, memUSS)</span>
<span class="c1">#</span>
<span class="c1">#             memRSS = obj.getMemoryRSS()</span>
<span class="c1">#</span>
<span class="c1">#             print(&quot;Total Memory in RSS&quot;, memRSS)</span>
<span class="c1">#</span>
<span class="c1">#             run = obj.getRuntime()</span>
<span class="c1">#</span>
<span class="c1">#             print(&quot;Total ExecutionTime in seconds:&quot;, run)</span>
<span class="c1">#</span>





<span class="n">__copyright__</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">Copyright (C)  2021 Rage Uday Kiran</span>

<span class="s2">     This program is free software: you can redistribute it and/or modify</span>
<span class="s2">     it under the terms of the GNU General Public License as published by</span>
<span class="s2">     the Free Software Foundation, either version 3 of the License, or</span>
<span class="s2">     (at your option) any later version.</span>

<span class="s2">     This program is distributed in the hope that it will be useful,</span>
<span class="s2">     but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="s2">     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="s2">     GNU General Public License for more details.</span>

<span class="s2">     You should have received a copy of the GNU General Public License</span>
<span class="s2">     along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.</span>
<span class="s2">&quot;&quot;&quot;</span>


<span class="kn">from</span> <span class="nn">PAMI.frequentPattern.maximal</span> <span class="kn">import</span> <span class="n">abstract</span> <span class="k">as</span> <span class="n">_ab</span>
<span class="kn">from</span> <span class="nn">deprecated</span> <span class="kn">import</span> <span class="n">deprecated</span>


<span class="n">_minSup</span> <span class="o">=</span> <span class="nb">str</span><span class="p">()</span>
<span class="k">global</span> <span class="n">maximalTree</span>


<span class="k">class</span> <span class="nc">_Node</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class used to represent the node of frequentPatternTree</span>

<span class="sd">    :Attributes:</span>
<span class="sd">        item : int</span>
<span class="sd">            storing item of a node</span>
<span class="sd">        counter : list</span>
<span class="sd">            To maintain the support of the node</span>
<span class="sd">        parent : node</span>
<span class="sd">            To maintain the parent of every node</span>
<span class="sd">        children : list</span>
<span class="sd">            To maintain the children of node</span>

<span class="sd">    :Methods:</span>
<span class="sd">        addChild(itemName)</span>
<span class="sd">            storing the children to their respective parent nodes</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">children</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializing the Node class</span>
<span class="sd">        :param item: Storing the item of a node</span>
<span class="sd">        :type item: int or None</span>
<span class="sd">        :param children: To maintain the children of a node</span>
<span class="sd">        :type children: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">item</span> <span class="o">=</span> <span class="n">item</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">children</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">counter</span> <span class="o">=</span> <span class="nb">int</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">addChild</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adding a child to the created nodes</span>
<span class="sd">        :param node: node object</span>
<span class="sd">        :type node: Node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
        <span class="n">node</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span>


<span class="k">class</span> <span class="nc">_Tree</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class used to represent the frequentPatternGrowth tree structure</span>

<span class="sd">    :Attributes:</span>
<span class="sd">        root : Node</span>
<span class="sd">               Represents the root node of the tree</span>
<span class="sd">        summaries : dictionary</span>
<span class="sd">                storing the nodes with same item name</span>
<span class="sd">        info : dictionary</span>
<span class="sd">                stores the support of items</span>


<span class="sd">    :Methods:</span>

<span class="sd">        addTransaction(transaction)</span>
<span class="sd">            creating transaction as a branch in frequentPatternTree</span>
<span class="sd">        addConditionalTransaction(prefixPaths, supportOfItems)</span>
<span class="sd">            construct the conditional tree for prefix paths</span>
<span class="sd">        condPatterns(Node)</span>
<span class="sd">            generates the conditional patterns from tree for specific node</span>
<span class="sd">        conditionalTransaction(prefixPaths,Support)</span>
<span class="sd">            takes the prefixPath of a node and support at child of the path and extract the frequent items from</span>
<span class="sd">            prefixPaths and generates prefixPaths with items which are frequent</span>
<span class="sd">        remove(Node)</span>
<span class="sd">            removes the node from tree once after generating all the patterns respective to the node</span>
<span class="sd">        generatePatterns(Node)</span>
<span class="sd">            starts from the root node of the tree and mines the frequent patterns</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">_Node</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="p">{})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">summaries</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1">#self.maximalTree = _MPTree()</span>

    <span class="k">def</span> <span class="nf">addTransaction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transaction</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Adding transactions into tree</span>

<span class="sd">        :param transaction: represents the transaction in a database</span>

<span class="sd">        :type transaction: list</span>

<span class="sd">        :return: tree</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">currentNode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">transaction</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">transaction</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">currentNode</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">newNode</span> <span class="o">=</span> <span class="n">_Node</span><span class="p">(</span><span class="n">transaction</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">{})</span>
                <span class="n">newNode</span><span class="o">.</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">currentNode</span><span class="o">.</span><span class="n">addChild</span><span class="p">(</span><span class="n">newNode</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">transaction</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">summaries</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">summaries</span><span class="p">[</span><span class="n">transaction</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newNode</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">summaries</span><span class="p">[</span><span class="n">transaction</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="n">newNode</span><span class="p">]</span>
                <span class="n">currentNode</span> <span class="o">=</span> <span class="n">newNode</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">currentNode</span> <span class="o">=</span> <span class="n">currentNode</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">transaction</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="n">currentNode</span><span class="o">.</span><span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">addConditionalTransaction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transaction</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Loading the database into a tree</span>

<span class="sd">        :param transaction: conditional transaction of a node</span>

<span class="sd">        :type transaction: list</span>

<span class="sd">        :param count: the support of conditional transaction</span>

<span class="sd">        :type count: int</span>

<span class="sd">        :return: conditional tree</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">currentNode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">transaction</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">transaction</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">currentNode</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">newNode</span> <span class="o">=</span> <span class="n">_Node</span><span class="p">(</span><span class="n">transaction</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">{})</span>
                <span class="n">newNode</span><span class="o">.</span><span class="n">counter</span> <span class="o">=</span> <span class="n">count</span>
                <span class="n">currentNode</span><span class="o">.</span><span class="n">addChild</span><span class="p">(</span><span class="n">newNode</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">transaction</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">summaries</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">summaries</span><span class="p">[</span><span class="n">transaction</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newNode</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">summaries</span><span class="p">[</span><span class="n">transaction</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="n">newNode</span><span class="p">]</span>
                <span class="n">currentNode</span> <span class="o">=</span> <span class="n">newNode</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">currentNode</span> <span class="o">=</span> <span class="n">currentNode</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">transaction</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="n">currentNode</span><span class="o">.</span><span class="n">counter</span> <span class="o">+=</span> <span class="n">count</span>

    <span class="k">def</span> <span class="nf">getConditionalPatterns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates all the conditional patterns of respective node</span>
<span class="sd">        :param alpha: it represents the Node in tree</span>
<span class="sd">        :type alpha: int</span>
<span class="sd">        :return: conditional patterns of a node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">finalPatterns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">finalSets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">summaries</span><span class="p">[</span><span class="n">alpha</span><span class="p">]:</span>
            <span class="n">set1</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">counter</span>
            <span class="n">set2</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="n">i</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">item</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">set2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">item</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">parent</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">set2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">set2</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
                <span class="n">finalPatterns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">set2</span><span class="p">)</span>
                <span class="n">finalSets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">set1</span><span class="p">)</span>
        <span class="n">finalPatterns</span><span class="p">,</span> <span class="n">finalSets</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conditionalTransactions</span><span class="p">(</span><span class="n">finalPatterns</span><span class="p">,</span> <span class="n">finalSets</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">finalPatterns</span><span class="p">,</span> <span class="n">finalSets</span><span class="p">,</span> <span class="n">info</span>

    <span class="k">def</span> <span class="nf">conditionalTransactions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condPatterns</span><span class="p">,</span> <span class="n">condFreq</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        sorting and removing the items from conditional transactions which don&#39;t satisfy minSup</span>
<span class="sd">        :param condPatterns: conditional patterns if a node</span>
<span class="sd">        :type condPatterns: list</span>
<span class="sd">        :param condFreq: frequency at leaf node of conditional transaction</span>
<span class="sd">        :type condFreq: int</span>
<span class="sd">        :return: conditional patterns and their frequency respectively</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">global</span> <span class="n">_minSup</span>
        <span class="n">pat</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">data1</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">condPatterns</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">condPatterns</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data1</span><span class="p">:</span>
                    <span class="n">data1</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">condFreq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data1</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">condFreq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">updatedDict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">updatedDict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data1</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;=</span> <span class="n">_minSup</span><span class="p">}</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">condPatterns</span><span class="p">:</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">p</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">updatedDict</span><span class="p">]</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">updatedDict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="o">-</span><span class="n">x</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">trans</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">pat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trans</span><span class="p">)</span>
                <span class="n">tids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">condFreq</span><span class="p">[</span><span class="n">count</span><span class="p">])</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">pat</span><span class="p">,</span> <span class="n">tids</span><span class="p">,</span> <span class="n">updatedDict</span>

    <span class="k">def</span> <span class="nf">removeNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeValue</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        To remove the node from the original tree</span>
<span class="sd">        :param nodeValue: leaf node of tree</span>
<span class="sd">        :type nodeValue: int</span>
<span class="sd">        :return: tree after deleting node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">summaries</span><span class="p">[</span><span class="n">nodeValue</span><span class="p">]:</span>
            <span class="k">del</span> <span class="n">i</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">nodeValue</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">generatePatterns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">patterns</span><span class="p">,</span> <span class="n">maximalTree</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates the patterns</span>
<span class="sd">        :param prefix: forms the combination of items</span>
<span class="sd">        :type prefix: str</span>
<span class="sd">        :param patterns: the patterns we want to generate for this node</span>
<span class="sd">        :type patterns: list</span>
<span class="sd">        :return: the maximal frequent patterns</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">summaries</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="o">-</span><span class="n">x</span><span class="p">)):</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="n">prefix</span><span class="p">[:]</span>
            <span class="n">pattern</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">condPatterns</span><span class="p">,</span> <span class="n">tids</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getConditionalPatterns</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">conditional_tree</span> <span class="o">=</span> <span class="n">_Tree</span><span class="p">()</span>
            <span class="n">conditional_tree</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">pattern</span><span class="p">[:]</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">la</span> <span class="ow">in</span> <span class="n">info</span><span class="p">:</span>
                <span class="n">tail</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">la</span><span class="p">)</span>
            <span class="n">sub</span> <span class="o">=</span> <span class="n">head</span> <span class="o">+</span> <span class="n">tail</span>
            <span class="k">if</span> <span class="n">maximalTree</span><span class="o">.</span><span class="n">checkerSub</span><span class="p">(</span><span class="n">sub</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">pat</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">condPatterns</span><span class="p">)):</span>
                    <span class="n">conditional_tree</span><span class="o">.</span><span class="n">addConditionalTransaction</span><span class="p">(</span><span class="n">condPatterns</span><span class="p">[</span><span class="n">pat</span><span class="p">],</span> <span class="n">tids</span><span class="p">[</span><span class="n">pat</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">condPatterns</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">conditional_tree</span><span class="o">.</span><span class="n">generatePatterns</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">patterns</span><span class="p">,</span> <span class="n">maximalTree</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">maximalTree</span><span class="o">.</span><span class="n">addTransaction</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
                    <span class="n">patterns</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">pattern</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">removeNode</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_MNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class used to represent the node in maximal tree</span>

<span class="sd">    :Attributes:</span>
<span class="sd">        item : int</span>
<span class="sd">            storing item of a node</span>
<span class="sd">        children : list</span>
<span class="sd">            To maintain the children of node</span>

<span class="sd">    :Methods:</span>
<span class="sd">        addChild(itemName)</span>
<span class="sd">            storing the children to their respective parent nodes</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">children</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">item</span> <span class="o">=</span> <span class="n">item</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">children</span>

    <span class="k">def</span> <span class="nf">addChild</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        To add the children details to a parent node</span>
<span class="sd">        :param node: children node</span>
<span class="sd">        :type node: _MNode</span>
<span class="sd">        :return: adding children details to parent node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
        <span class="n">node</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span>


<span class="k">class</span> <span class="nc">_MPTree</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class used to represent the frequentPatternGrowth tree structure</span>

<span class="sd">    :Attributes:</span>

<span class="sd">        root : Node</span>
<span class="sd">            Represents the root node of the tree</span>
<span class="sd">        summaries : dictionary</span>
<span class="sd">            storing the nodes with same item name</span>


<span class="sd">    :Methods:</span>

<span class="sd">        addTransaction(transaction)</span>
<span class="sd">            creating transaction as a branch in frequentPatternTree</span>
<span class="sd">        addConditionalTransaction(prefixPaths, supportOfItems)</span>
<span class="sd">            construct the conditional tree for prefix paths</span>
<span class="sd">        checkerSub(items):</span>
<span class="sd">            Given a set of items to the subset of them is present or not</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">_MNode</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="p">{})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">summaries</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">addTransaction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transaction</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        To construct the maximal frequent pattern into maximal tree</span>
<span class="sd">        :param transaction: the maximal frequent patterns extracted till now</span>
<span class="sd">        :type transaction: list</span>
<span class="sd">        :return: the maximal tree</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">currentNode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
        <span class="n">transaction</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">transaction</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">transaction</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">currentNode</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">newNode</span> <span class="o">=</span> <span class="n">_MNode</span><span class="p">(</span><span class="n">transaction</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">{})</span>
                <span class="n">currentNode</span><span class="o">.</span><span class="n">addChild</span><span class="p">(</span><span class="n">newNode</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">transaction</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">summaries</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">summaries</span><span class="p">[</span><span class="n">transaction</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">newNode</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">summaries</span><span class="p">[</span><span class="n">transaction</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="n">newNode</span><span class="p">]</span>
                <span class="n">currentNode</span> <span class="o">=</span> <span class="n">newNode</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">currentNode</span> <span class="o">=</span> <span class="n">currentNode</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">transaction</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

    <span class="k">def</span> <span class="nf">checkerSub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">items</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        To check the subset of pattern present in tree</span>
<span class="sd">        :param items: the sub frequent pattern</span>
<span class="sd">        :type items: list</span>
<span class="sd">        :return: checks if subset present in the tree</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">items</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">item</span> <span class="o">=</span> <span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">summaries</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">summaries</span><span class="p">[</span><span class="n">item</span><span class="p">]:</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">parent</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">cur</span><span class="o">.</span><span class="n">item</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">cur</span><span class="o">.</span><span class="n">item</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">):</span>
                        <span class="k">return</span> <span class="mi">0</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">parent</span>
        <span class="k">return</span> <span class="mi">1</span>


<span class="c1"># Initialising the  variable for maximal tree</span>
<span class="c1">#maximalTree = _MPTree()</span>


<div class="viewcode-block" id="MaxFPGrowth">
<a class="viewcode-back" href="../../../../PAMI.frequentPattern.maximal.html#PAMI.frequentPattern.maximal.MaxFPGrowth.MaxFPGrowth">[docs]</a>
<span class="k">class</span> <span class="nc">MaxFPGrowth</span><span class="p">(</span><span class="n">_ab</span><span class="o">.</span><span class="n">_frequentPatterns</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :Description: MaxFP-Growth is one of the fundamental algorithm to discover maximal frequent patterns in a transactional database.</span>

<span class="sd">    :Reference:   Grahne, G. and Zhu, J., &quot;High Performance Mining of Maximal Frequent itemSets&quot;,</span>
<span class="sd">                  http://users.encs.concordia.ca/~grahne/papers/hpdm03.pdf</span>

<span class="sd">    :param  iFile: str :</span>
<span class="sd">                   Name of the Input file to mine complete set of frequent patterns</span>
<span class="sd">    :param  oFile: str :</span>
<span class="sd">                   Name of the output file to store complete set of frequent patterns</span>
<span class="sd">    :param  minSup: int or float or str :</span>
<span class="sd">                   The user can specify minSup either in count or proportion of database size. If the program detects the data type of minSup is integer, then it treats minSup is expressed in count.</span>
<span class="sd">    :param  maxPer: float :</span>
<span class="sd">                   The user can specify maxPer in count or proportion of database size. If the program detects the data type of maxPer is integer, then it treats maxPer is expressed in count.</span>

<span class="sd">    :param  sep: str :</span>
<span class="sd">                   This variable is used to distinguish items from one another in a transaction. The default seperator is tab space. However, the users can override their default separator.</span>



<span class="sd">    :Attributes:</span>

<span class="sd">        startTime : float</span>
<span class="sd">          To record the start time of the mining process</span>

<span class="sd">        endTime : float</span>
<span class="sd">          To record the completion time of the mining process</span>

<span class="sd">        finalPatterns : dict</span>
<span class="sd">          Storing the complete set of patterns in a dictionary variable</span>

<span class="sd">        memoryUSS : float</span>
<span class="sd">          To store the total amount of USS memory consumed by the program</span>

<span class="sd">        memoryRSS : float</span>
<span class="sd">          To store the total amount of RSS memory consumed by the program</span>

<span class="sd">        Database : list</span>
<span class="sd">          To store the transactions of a database in list</span>

<span class="sd">        mapSupport : Dictionary</span>
<span class="sd">            To maintain the information of item and their frequency</span>
<span class="sd">        lno : int</span>
<span class="sd">            it represents the total no of transactions</span>
<span class="sd">        tree : class</span>
<span class="sd">            it represents the Tree class</span>
<span class="sd">        itemSetCount : int</span>
<span class="sd">            it represents the total no of patterns</span>
<span class="sd">        finalPatterns : dict</span>
<span class="sd">            it represents to store the patterns</span>


<span class="sd">    **Methods to execute code on terminal**</span>
<span class="sd">    ---------------------------------------------------------</span>

<span class="sd">    .. code-block:: console</span>

<span class="sd">      Format:</span>

<span class="sd">      (.venv) $ python3 MaxFPGrowth.py &lt;inputFile&gt; &lt;outputFile&gt; &lt;minSup&gt;</span>

<span class="sd">      Example Usage:</span>

<span class="sd">      (.venv) $ python3 MaxFPGrowth.py sampleDB.txt patterns.txt 0.3</span>

<span class="sd">    .. note:: minSup will be considered in percentage of database transactions</span>



<span class="sd">    **Importing this algorithm into a python program**</span>
<span class="sd">    ---------------------------------------------------------</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">            from PAMI.frequentPattern.maximal import MaxFPGrowth as alg</span>

<span class="sd">            obj = alg.MaxFPGrowth(&quot;../basic/sampleTDB.txt&quot;, &quot;2&quot;)</span>

<span class="sd">            obj.mine()</span>

<span class="sd">            frequentPatterns = obj.getPatterns()</span>

<span class="sd">            print(&quot;Total number of Frequent Patterns:&quot;, len(frequentPatterns))</span>

<span class="sd">            obj.savePatterns(&quot;patterns&quot;)</span>

<span class="sd">            Df = obj.getPatternsAsDataFrame()</span>

<span class="sd">            memUSS = obj.getMemoryUSS()</span>

<span class="sd">            print(&quot;Total Memory in USS:&quot;, memUSS)</span>

<span class="sd">            memRSS = obj.getMemoryRSS()</span>

<span class="sd">            print(&quot;Total Memory in RSS&quot;, memRSS)</span>

<span class="sd">            run = obj.getRuntime()</span>

<span class="sd">            print(&quot;Total ExecutionTime in seconds:&quot;, run)</span>


<span class="sd">    **Credits:**</span>
<span class="sd">    -------------------</span>
<span class="sd">                The complete program was written by P.Likhitha  under the supervision of Professor Rage Uday Kiran.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_startTime</span> <span class="o">=</span> <span class="nb">float</span><span class="p">()</span>
    <span class="n">_endTime</span> <span class="o">=</span> <span class="nb">float</span><span class="p">()</span>
    <span class="n">_minSup</span> <span class="o">=</span> <span class="nb">str</span><span class="p">()</span>
    <span class="n">_maxPer</span> <span class="o">=</span> <span class="nb">float</span><span class="p">()</span>
    <span class="n">_finalPatterns</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">_iFile</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span>
    <span class="n">_oFile</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span>
    <span class="n">_sep</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span>
    <span class="n">_memoryUSS</span> <span class="o">=</span> <span class="nb">float</span><span class="p">()</span>
    <span class="n">_memoryRSS</span> <span class="o">=</span> <span class="nb">float</span><span class="p">()</span>
    <span class="n">_Database</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">_rank</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">_rankdup</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">_lno</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">_maximalTree</span> <span class="o">=</span> <span class="nb">str</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_creatingItemSets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Storing the complete transactions of the database/input file in a database variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Database</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iFile</span><span class="p">,</span> <span class="n">_ab</span><span class="o">.</span><span class="n">_pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iFile</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;its empty..&quot;</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iFile</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">if</span> <span class="s1">&#39;Transactions&#39;</span> <span class="ow">in</span> <span class="n">i</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_Database</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iFile</span><span class="p">[</span><span class="s1">&#39;Transactions&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iFile</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">_ab</span><span class="o">.</span><span class="n">_validators</span><span class="o">.</span><span class="n">url</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iFile</span><span class="p">):</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">_ab</span><span class="o">.</span><span class="n">_urlopen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iFile</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                    <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
                    <span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sep</span><span class="p">)]</span>
                    <span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">temp</span> <span class="k">if</span> <span class="n">x</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_Database</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iFile</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                            <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                            <span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sep</span><span class="p">)]</span>
                            <span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">temp</span> <span class="k">if</span> <span class="n">x</span><span class="p">]</span>
                            <span class="c1">#print(line)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_Database</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;File Not Found&quot;</span><span class="p">)</span>
                    <span class="n">quit</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_frequentOneItem</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        To extract the one-length frequent itemSets</span>
<span class="sd">        :return: 1-length frequent items</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_mapSupport</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Database</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">tr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_mapSupport</span><span class="p">:</span>
                    <span class="n">_mapSupport</span><span class="p">[</span><span class="n">tr</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_mapSupport</span><span class="p">[</span><span class="n">tr</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">_mapSupport</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">_mapSupport</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minSup</span><span class="p">}</span>
        <span class="c1">#print(len(mapSupport), self.minSup)</span>
        <span class="n">genList</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">_mapSupport</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">index</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">genList</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">_mapSupport</span><span class="p">,</span> <span class="n">genList</span>

    <span class="k">def</span> <span class="nf">_updateTransactions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">oneLength</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        To sort the transactions in their support descending order and allocating ranks respectively</span>
<span class="sd">        :param oneLength: 1-length frequent items in dictionary</span>
<span class="sd">        :type oneLength: dict</span>
<span class="sd">        :return: returning the sorted list</span>
<span class="sd">        :Example: oneLength = {&#39;a&#39;:7, &#39;b&#39;: 5, &#39;c&#39;:&#39;4&#39;, &#39;d&#39;:3}</span>
<span class="sd">                    rank = {&#39;a&#39;:0, &#39;b&#39;:1, &#39;c&#39;:2, &#39;d&#39;:3}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">list1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Database</span><span class="p">:</span>
            <span class="n">list2</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">tr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">oneLength</span><span class="p">:</span>
                    <span class="n">list2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rank</span><span class="p">[</span><span class="n">tr</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">list2</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">list2</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                <span class="n">list1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">list2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">list1</span>


    <span class="k">def</span> <span class="nf">_buildTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">info</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        creating the root node as null in fp-tree and adding all transactions into tree.</span>
<span class="sd">        :param data: updated transactions</span>
<span class="sd">        :type data: dict</span>
<span class="sd">        :param info: rank of items in transactions</span>
<span class="sd">        :type info: dict</span>
<span class="sd">        :return: fp-tree</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rootNode</span> <span class="o">=</span> <span class="n">_Tree</span><span class="p">()</span>
        <span class="n">rootNode</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
            <span class="n">rootNode</span><span class="o">.</span><span class="n">addTransaction</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">rootNode</span>


    <span class="k">def</span> <span class="nf">_convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        To convert the type of user specified minSup value</span>
<span class="sd">        :param value: user specified minSup value</span>
<span class="sd">        :type value: int or float or str</span>
<span class="sd">        :return: converted type</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">float</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Database</span><span class="p">)</span> <span class="o">*</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Database</span><span class="p">))</span> <span class="o">*</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_convertItems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">itemSet</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        To convert the item ranks into their original item names</span>
<span class="sd">        :param itemSet: itemSet or a pattern</span>
<span class="sd">        :type itemSet: list</span>
<span class="sd">        :return: original pattern</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">itemSet</span><span class="p">:</span>
            <span class="n">t1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rankdup</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">t1</span>

<div class="viewcode-block" id="MaxFPGrowth.startMine">
<a class="viewcode-back" href="../../../../PAMI.frequentPattern.maximal.html#PAMI.frequentPattern.maximal.MaxFPGrowth.MaxFPGrowth.startMine">[docs]</a>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;It is recommended to use &#39;mine()&#39; instead of &#39;startMine()&#39; for mining process. Starting from January 2025, &#39;startMine()&#39; will be completely terminated.&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">startMine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mining process will start from this function</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mine</span><span class="p">()</span></div>


<div class="viewcode-block" id="MaxFPGrowth.mine">
<a class="viewcode-back" href="../../../../PAMI.frequentPattern.maximal.html#PAMI.frequentPattern.maximal.MaxFPGrowth.MaxFPGrowth.mine">[docs]</a>
    <span class="k">def</span> <span class="nf">mine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mining process will start from this function</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">global</span> <span class="n">_minSup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_startTime</span> <span class="o">=</span> <span class="n">_ab</span><span class="o">.</span><span class="n">_time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iFile</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Please enter the file path or file name:&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minSup</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Please enter the Minimum Support&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_creatingItemSets</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_minSup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_minSup</span><span class="p">)</span>
        <span class="n">_minSup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minSup</span>
        <span class="n">generatedItems</span><span class="p">,</span> <span class="n">pfList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frequentOneItem</span><span class="p">()</span>
        <span class="n">updatedTransactions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_updateTransactions</span><span class="p">(</span><span class="n">generatedItems</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rankdup</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">info</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_rank</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">generatedItems</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">patterns</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finalPatterns</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maximalTree</span> <span class="o">=</span> <span class="n">_MPTree</span><span class="p">()</span>
        <span class="n">Tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buildTree</span><span class="p">(</span><span class="n">updatedTransactions</span><span class="p">,</span> <span class="n">info</span><span class="p">)</span>
        <span class="n">Tree</span><span class="o">.</span><span class="n">generatePatterns</span><span class="p">([],</span> <span class="n">patterns</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maximalTree</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">patterns</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="nb">str</span><span class="p">()</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convertItems</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
                <span class="n">pattern</span> <span class="o">=</span> <span class="n">pattern</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_finalPatterns</span><span class="p">[</span><span class="n">pattern</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_endTime</span> <span class="o">=</span> <span class="n">_ab</span><span class="o">.</span><span class="n">_time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">process</span> <span class="o">=</span> <span class="n">_ab</span><span class="o">.</span><span class="n">_psutil</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">_ab</span><span class="o">.</span><span class="n">_os</span><span class="o">.</span><span class="n">getpid</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_memoryUSS</span> <span class="o">=</span> <span class="nb">float</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_memoryRSS</span> <span class="o">=</span> <span class="nb">float</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_memoryUSS</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">memory_full_info</span><span class="p">()</span><span class="o">.</span><span class="n">uss</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_memoryRSS</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">memory_info</span><span class="p">()</span><span class="o">.</span><span class="n">rss</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Maximal Frequent patterns were generated successfully using MaxFp-Growth algorithm &quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="MaxFPGrowth.getMemoryUSS">
<a class="viewcode-back" href="../../../../PAMI.frequentPattern.maximal.html#PAMI.frequentPattern.maximal.MaxFPGrowth.MaxFPGrowth.getMemoryUSS">[docs]</a>
    <span class="k">def</span> <span class="nf">getMemoryUSS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Total amount of USS memory consumed by the mining process will be retrieved from this function</span>
<span class="sd">        :return: returning USS memory consumed by the mining process</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memoryUSS</span></div>


<div class="viewcode-block" id="MaxFPGrowth.getMemoryRSS">
<a class="viewcode-back" href="../../../../PAMI.frequentPattern.maximal.html#PAMI.frequentPattern.maximal.MaxFPGrowth.MaxFPGrowth.getMemoryRSS">[docs]</a>
    <span class="k">def</span> <span class="nf">getMemoryRSS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Total amount of RSS memory consumed by the mining process will be retrieved from this function</span>
<span class="sd">        :return: returning RSS memory consumed by the mining process</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memoryRSS</span></div>


<div class="viewcode-block" id="MaxFPGrowth.getRuntime">
<a class="viewcode-back" href="../../../../PAMI.frequentPattern.maximal.html#PAMI.frequentPattern.maximal.MaxFPGrowth.MaxFPGrowth.getRuntime">[docs]</a>
    <span class="k">def</span> <span class="nf">getRuntime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculating the total amount of runtime taken by the mining process</span>
<span class="sd">        :return: returning total amount of runtime taken by the mining process</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endTime</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_startTime</span></div>


<div class="viewcode-block" id="MaxFPGrowth.getPatternsAsDataFrame">
<a class="viewcode-back" href="../../../../PAMI.frequentPattern.maximal.html#PAMI.frequentPattern.maximal.MaxFPGrowth.MaxFPGrowth.getPatternsAsDataFrame">[docs]</a>
    <span class="k">def</span> <span class="nf">getPatternsAsDataFrame</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Storing final frequent patterns in a dataframe</span>
<span class="sd">        :return: returning frequent patterns in a dataframe</span>
<span class="sd">        :rtype: pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">dataFrame</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalPatterns</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">),</span> <span class="n">b</span><span class="p">])</span>
            <span class="n">dataFrame</span> <span class="o">=</span> <span class="n">_ab</span><span class="o">.</span><span class="n">_pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Patterns&#39;</span><span class="p">,</span> <span class="s1">&#39;Support&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">dataFrame</span></div>


<div class="viewcode-block" id="MaxFPGrowth.save">
<a class="viewcode-back" href="../../../../PAMI.frequentPattern.maximal.html#PAMI.frequentPattern.maximal.MaxFPGrowth.MaxFPGrowth.save">[docs]</a>
    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outFile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Complete set of frequent patterns will be loaded in to a output file</span>
<span class="sd">        :param outFile: name of the output file</span>
<span class="sd">        :type outFile: csvfile</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_oFile</span> <span class="o">=</span> <span class="n">outFile</span>
        <span class="n">writer</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_oFile</span><span class="p">,</span> <span class="s1">&#39;w+&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalPatterns</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">s1</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;:&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">s1</span><span class="p">)</span></div>


<div class="viewcode-block" id="MaxFPGrowth.getPatterns">
<a class="viewcode-back" href="../../../../PAMI.frequentPattern.maximal.html#PAMI.frequentPattern.maximal.MaxFPGrowth.MaxFPGrowth.getPatterns">[docs]</a>
    <span class="k">def</span> <span class="nf">getPatterns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to send the set of frequent patterns after completion of the mining process</span>
<span class="sd">        :return: returning frequent patterns</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalPatterns</span></div>

    
<div class="viewcode-block" id="MaxFPGrowth.printResults">
<a class="viewcode-back" href="../../../../PAMI.frequentPattern.maximal.html#PAMI.frequentPattern.maximal.MaxFPGrowth.MaxFPGrowth.printResults">[docs]</a>
    <span class="k">def</span> <span class="nf">printResults</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This functon is used to print the results</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Total number of Maximal Frequent Patterns: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getPatterns</span><span class="p">()))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Runtime: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getRuntime</span><span class="p">()))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Memory (RSS): &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getMemoryRSS</span><span class="p">()))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Memory (USS): &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getMemoryUSS</span><span class="p">()))</span></div>
</div>



<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">_ap</span> <span class="o">=</span> <span class="nb">str</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_ab</span><span class="o">.</span><span class="n">_sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">_ab</span><span class="o">.</span><span class="n">_sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_ab</span><span class="o">.</span><span class="n">_sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">_ap</span> <span class="o">=</span> <span class="n">MaxFPGrowth</span><span class="p">(</span><span class="n">_ab</span><span class="o">.</span><span class="n">_sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">_ab</span><span class="o">.</span><span class="n">_sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">_ab</span><span class="o">.</span><span class="n">_sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_ab</span><span class="o">.</span><span class="n">_sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">_ap</span> <span class="o">=</span> <span class="n">MaxFPGrowth</span><span class="p">(</span><span class="n">_ab</span><span class="o">.</span><span class="n">_sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">_ab</span><span class="o">.</span><span class="n">_sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">_ap</span><span class="o">.</span><span class="n">startMine</span><span class="p">()</span>
        <span class="n">_ap</span><span class="o">.</span><span class="n">mine</span><span class="p">()</span>
        <span class="n">_ap</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">_ab</span><span class="o">.</span><span class="n">_sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total number of Maximal Frequent Patterns:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">_ap</span><span class="o">.</span><span class="n">getPatterns</span><span class="p">()))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total Memory in USS:&quot;</span><span class="p">,</span>  <span class="n">_ap</span><span class="o">.</span><span class="n">getMemoryUSS</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total Memory in RSS&quot;</span><span class="p">,</span> <span class="n">_ap</span><span class="o">.</span><span class="n">getMemoryRSS</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total ExecutionTime in ms:&quot;</span><span class="p">,</span> <span class="n">_ap</span><span class="o">.</span><span class="n">getRuntime</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error! The number of input parameters do not match the total number of parameters provided&quot;</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, RAGE Uday Kiran.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>